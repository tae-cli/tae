# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/aruba/all/aruba.rbi
#
# aruba-1.0.0

module Aruba
  def self.config; end
  def self.configure(&block); end
  def self.platform; end
end
class String
  def strip_heredoc; end
end
class Aruba::ArubaPath
  def <<(p); end
  def [](index); end
  def initialize(path); end
  def pop; end
  def push(p); end
  def to_pathname; end
  def to_s; end
  def to_str; end
end
module Aruba::Platforms
end
class Aruba::Platforms::SimpleTable
  def hash; end
  def initialize(hash, opts); end
  def opts; end
  def to_s; end
end
class Aruba::Platforms::UnixCommandString
  def initialize(command, *arguments); end
  def to_a; end
end
class Aruba::Platforms::UnixWhich
  def call(program, path = nil); end
  def initialize; end
  def whiches; end
end
class Aruba::Platforms::UnixWhich::DefaultWhich
  def call(program, path); end
  def self.match?(*arg0); end
end
class Aruba::Platforms::UnixWhich::AbsoluteOrRelativePathWhich
  def call(program, _path); end
  def self.match?(program); end
end
class Aruba::Platforms::UnixWhich::ProgramWhich
  def call(program, path); end
  def self.match?(program); end
end
class Aruba::Platforms::DetermineFileSize
  def call(path); end
end
class Aruba::FileSize
  def <=>(other); end
  def bytes; end
  def coerce(other); end
  def divisor; end
  def initialize(bytes); end
  def inspect; end
  def to_byte; end
  def to_f; end
  def to_gibi_byte; end
  def to_i; end
  def to_kibi_byte; end
  def to_mebi_byte; end
  def to_s; end
  include Comparable
end
class Aruba::Platforms::DetermineDiskUsage
  def call(paths); end
  def minimum_disk_space_used(path); end
end
class Aruba::Platforms::ArubaFileCreator
  def call(path, content, check_presence = nil); end
end
class Aruba::Platforms::ArubaFixedSizeFileCreator
  def call(path, size, check_presence); end
end
class Aruba::Platforms::LocalEnvironment
  def call(env); end
end
class Aruba::ArubaLogger
  def debug(msg); end
  def error(msg); end
  def fatal(msg); end
  def format_debug(l); end
  def format_standard(l); end
  def info(msg); end
  def initialize(opts = nil); end
  def logger; end
  def mode; end
  def mode=(m); end
  def mode?(m); end
  def unknown(msg); end
  def warn(msg); end
end
class Aruba::Colorizer
  def cyan(string); end
  def self.coloring; end
  def self.coloring=(arg0); end
  def self.coloring?; end
end
class Aruba::Platforms::Announcer
  def activate(*chns); end
  def activated?(channel); end
  def after_init; end
  def announce(channel, *args); end
  def announcer; end
  def announcers; end
  def channels; end
  def colorizer; end
  def initialize; end
  def mode; end
  def mode=(m); end
  def output_format(channel, string = nil, &block); end
  def output_formats; end
  def reset; end
end
class Aruba::Platforms::Announcer::BaseAnnouncer
  def mode?(m); end
end
class Aruba::Platforms::Announcer::KernelPutsAnnouncer < Aruba::Platforms::Announcer::BaseAnnouncer
  def announce(message); end
  def mode; end
end
class Aruba::Platforms::Announcer::PutsAnnouncer < Aruba::Platforms::Announcer::BaseAnnouncer
  def announce(message); end
  def mode; end
end
class Aruba::Error < StandardError
end
class Aruba::UserError < StandardError
end
class Aruba::LaunchError < Aruba::Error
end
class Aruba::UnknownOptionError < ArgumentError
end
class Aruba::CommandAlreadyStoppedError < Aruba::Error
end
class Aruba::NoCommandHasBeenStartedError < Aruba::Error
end
class Aruba::NoCommandHasBeenStoppedError < Aruba::Error
end
class Aruba::CommandNotFoundError < ArgumentError
end
class Aruba::CommandAlreadyStartedError < Aruba::Error
end
class Aruba::EventNameResolveError < StandardError
end
class Aruba::NoEventError < StandardError
end
class Aruba::CommandMonitor
  def all_output; end
  def all_stderr; end
  def all_stdout; end
  def announcer; end
  def clear; end
  def find(cmd); end
  def initialize(opts = nil); end
  def last_command_started; end
  def last_command_started=(cmd); end
  def last_command_stopped; end
  def last_command_stopped=(cmd); end
  def register_command(cmd); end
  def registered_commands; end
end
class Aruba::CommandMonitor::DefaultLastCommandStopped
  def method_missing(*arg0); end
  def nil?; end
  def respond_to_missing?(*arg0); end
end
class Aruba::CommandMonitor::DefaultLastCommandStarted
  def method_missing(*arg0); end
  def nil?; end
  def respond_to_missing?(*arg0); end
end
class Aruba::Platforms::FilesystemStatus
  def atime(*args, &block); end
  def ctime(*args, &block); end
  def executable?(*args, &block); end
  def group; end
  def initialize(path); end
  def mode; end
  def mtime(*args, &block); end
  def owner; end
  def size(*args, &block); end
  def status; end
  def to_h; end
  extend Forwardable
end
class Aruba::Platforms::UnixPlatform
  def absolute_path?(path); end
  def announcer; end
  def builtin_shell_commands; end
  def chdir(dir_name, &block); end
  def chmod(mode, args, options); end
  def command?(path); end
  def command_monitor; end
  def command_string; end
  def cp(src, dest); end
  def create_file(*args); end
  def create_fixed_size_file(*args); end
  def current_ruby; end
  def default_shell; end
  def deprecated(msg); end
  def detect_ruby(cmd); end
  def determine_disk_usage(paths); end
  def determine_file_size(*args); end
  def directory?(f); end
  def environment_variables; end
  def executable?(f); end
  def exist?(f); end
  def expand_path(path, base); end
  def file?(f); end
  def filesystem_status; end
  def getwd; end
  def logger; end
  def mkdir(dir_name); end
  def mv(src, dest); end
  def relative_command?(path); end
  def relative_path?(path); end
  def require_matching_files(pattern, base); end
  def rm(paths, options = nil); end
  def self.match?; end
  def simple_table(hash, opts = nil); end
  def touch(args, options); end
  def which(program, path = nil); end
  def with_environment(env = nil, &block); end
  def write_file(path, content); end
end
class Aruba::Platforms::WindowsCommandString
  def cmd_path; end
  def escaped_arguments; end
  def escaped_command; end
  def initialize(command, *arguments); end
  def to_a; end
end
class Aruba::Platforms::UnixEnvironmentVariables
  def [](name); end
  def []=(name, value); end
  def actions; end
  def append(name, value); end
  def clear; end
  def delete(name); end
  def env; end
  def fetch(name, default = nil); end
  def hash_from_env; end
  def initialize(env = nil); end
  def key?(name); end
  def method_missing(name, *args, &block); end
  def nest; end
  def prepend(name, value); end
  def respond_to_missing?(name, _private); end
  def self.hash_from_env; end
  def to_h; end
  def update(other_env); end
end
class Aruba::Platforms::UnixEnvironmentVariables::UpdateAction
  def block; end
  def call(env); end
  def initialize(other_env, &block); end
  def other_env; end
end
class Aruba::Platforms::UnixEnvironmentVariables::RemoveAction
  def call(env); end
  def initialize(variables); end
  def variables; end
end
class Aruba::Platforms::WindowsEnvironmentVariables < Aruba::Platforms::UnixEnvironmentVariables
  def [](name); end
  def []=(name, value); end
  def append(name, value); end
  def delete(name); end
  def fetch(name, default = nil); end
  def initialize(env = nil); end
  def key?(name); end
  def prepend(name, value); end
  def self.hash_from_env; end
  def self.upcase_env(env); end
  def upcase_env(env); end
  def update(other_env, &block); end
end
class Aruba::Platforms::WindowsWhich
  def call(program, path = nil); end
  def initialize; end
  def whiches; end
  def windows_executable_extentions; end
end
class Aruba::Platforms::WindowsWhich::DefaultWhich
  def call(program, path); end
  def self.match?(*arg0); end
end
class Aruba::Platforms::WindowsWhich::AbsoluteOrRelativePathWhich
  def call(program, _path); end
  def self.match?(program); end
end
class Aruba::Platforms::WindowsWhich::ProgramWhich
  def call(program, path); end
  def self.match?(program); end
end
class Aruba::Platforms::WindowsPlatform < Aruba::Platforms::UnixPlatform
  def builtin_shell_commands; end
  def command_string; end
  def environment_variables; end
  def self.match?; end
  def which(program, path = nil); end
end
class Aruba::BasicConfiguration
  def ==(other); end
  def Contract(*args); end
  def after(name, context = nil, *args, &block); end
  def after?(name); end
  def before(name, context = nil, *args, &block); end
  def before?(name); end
  def configure; end
  def find_option(name); end
  def functype(funcname); end
  def hooks=(arg0); end
  def initialize; end
  def initialize_configuration; end
  def local_options; end
  def local_options=(arg0); end
  def make_copy; end
  def option?(name); end
  def reset; end
  def self.Contract(*args); end
  def self.__contracts_engine; end
  def self.add_option(name, value = nil); end
  def self.functype(funcname); end
  def self.known_options; end
  def self.option_accessor(name, opts = nil); end
  def self.option_reader(name, opts = nil); end
  def set_if_option(name, *args); end
  extend Contracts::MethodDecorators
  include Contracts
  include Contracts::Core
end
class Aruba::BasicConfiguration::Option
  def ==(other); end
  def default_value; end
  def initialize(opts = nil); end
  def name; end
  def name=(arg0); end
  def value; end
  def value=(arg0); end
end
class Aruba::InConfigWrapper
  def config; end
  def initialize(config); end
  def method_missing(name, *args); end
  def respond_to_missing?(*arg0); end
end
class Aruba::Hooks
  def append(label, block); end
  def execute(label, context, *args); end
  def exist?(label); end
  def initialize; end
  def store; end
end
module Aruba::Contracts
end
class Aruba::Contracts::RelativePath
  def self.valid?(value); end
end
class Aruba::Contracts::AbsolutePath
  def self.valid?(value); end
end
class Aruba::Contracts::Enum < Contracts::Builtin::CallableClass
  def initialize(*vals); end
  def valid?(val); end
  def vals; end
end
class Aruba::Contracts::IsPowerOfTwo
  def self.valid?(value); end
end
class Aruba::Configuration < Aruba::BasicConfiguration
  def __contracts_ruby_original_activate_announcer_on_command_failure_k8e97e97i2j5; end
  def __contracts_ruby_original_allow_absolute_paths_k8e97e98gm9f; end
  def __contracts_ruby_original_command_launcher_k8e97e95kwvo; end
  def __contracts_ruby_original_command_runtime_environment_k8e97e94k848; end
  def __contracts_ruby_original_command_search_paths_k8e97e94eraw; end
  def __contracts_ruby_original_console_history_file_k8e97e97154s; end
  def __contracts_ruby_original_exit_timeout_k8e97e927yn6; end
  def __contracts_ruby_original_fixtures_directories_k8e97e9355xt; end
  def __contracts_ruby_original_fixtures_path_prefix_k8e97e9128ca; end
  def __contracts_ruby_original_home_directory_k8e97e96gjf4; end
  def __contracts_ruby_original_io_wait_timeout_k8e97e92bi9t; end
  def __contracts_ruby_original_log_level_k8e97e96ddeq; end
  def __contracts_ruby_original_main_class_k8e97e954dtt; end
  def __contracts_ruby_original_physical_block_size_k8e97e97csg0; end
  def __contracts_ruby_original_remove_ansi_escape_sequences_k8e97e94bbml; end
  def __contracts_ruby_original_root_directory_k8e97e9123pl; end
  def __contracts_ruby_original_startup_wait_time_k8e97e93by28; end
  def __contracts_ruby_original_stop_signal_k8e97e92gkmk; end
  def __contracts_ruby_original_working_directory_k8e97e91arnk; end
  def activate_announcer_on_command_failure(*args, &blk); end
  def activate_announcer_on_command_failure=(*args, &blk); end
  def allow_absolute_paths(*args, &blk); end
  def allow_absolute_paths=(*args, &blk); end
  def command_launcher(*args, &blk); end
  def command_launcher=(*args, &blk); end
  def command_runtime_environment(*args, &blk); end
  def command_runtime_environment=(*args, &blk); end
  def command_search_paths(*args, &blk); end
  def command_search_paths=(*args, &blk); end
  def console_history_file(*args, &blk); end
  def console_history_file=(*args, &blk); end
  def exit_timeout(*args, &blk); end
  def exit_timeout=(*args, &blk); end
  def fixtures_directories(*args, &blk); end
  def fixtures_directories=(*args, &blk); end
  def fixtures_path_prefix(*args, &blk); end
  def home_directory(*args, &blk); end
  def home_directory=(*args, &blk); end
  def io_wait_timeout(*args, &blk); end
  def io_wait_timeout=(*args, &blk); end
  def log_level(*args, &blk); end
  def log_level=(*args, &blk); end
  def main_class(*args, &blk); end
  def main_class=(*args, &blk); end
  def physical_block_size(*args, &blk); end
  def physical_block_size=(*args, &blk); end
  def remove_ansi_escape_sequences(*args, &blk); end
  def remove_ansi_escape_sequences=(*args, &blk); end
  def root_directory(*args, &blk); end
  def startup_wait_time(*args, &blk); end
  def startup_wait_time=(*args, &blk); end
  def stop_signal(*args, &blk); end
  def stop_signal=(*args, &blk); end
  def working_directory(*args, &blk); end
  def working_directory=(*args, &blk); end
end
class Aruba::ConfigWrapper
  def ==(other); end
  def config; end
  def event_bus; end
  def initialize(config, event_bus); end
  def method_missing(name, *args, &block); end
  def respond_to?(m); end
  def respond_to_missing?(name, _include_private); end
end
module Aruba::Events
end
class Aruba::Events::BasicEvent
  def entity; end
  def initialize(entity); end
end
class Aruba::Events::CommandStopped < Aruba::Events::BasicEvent
end
class Aruba::Events::CommandStarted < Aruba::Events::BasicEvent
end
class Aruba::Events::ChangedEnvironmentVariable < Aruba::Events::BasicEvent
end
class Aruba::Events::AddedEnvironmentVariable < Aruba::Events::BasicEvent
end
class Aruba::Events::DeletedEnvironmentVariable < Aruba::Events::BasicEvent
end
class Aruba::Events::ChangedWorkingDirectory < Aruba::Events::BasicEvent
end
class Aruba::Events::ChangedConfiguration < Aruba::Events::BasicEvent
end
class Aruba::EventBus
  def initialize(resolver); end
  def notify(event); end
  def register(event_ids, handler_object = nil, &handler_proc); end
end
class Aruba::EventBus::NameResolver
  def default_namespace; end
  def initialize(default_namespace); end
  def resolvers; end
  def transform(event_id); end
end
module Aruba::EventBus::NameResolver::ResolveHelpers
  def camel_case(underscored_name); end
  def constantize(camel_cased_word); end
end
class Aruba::EventBus::NameResolver::ClassResolver
  def self.match?(event_id); end
  def self.supports; end
  def transform(_, event_id); end
end
class Aruba::EventBus::NameResolver::StringResolver
  def self.match?(event_id); end
  def self.supports; end
  def transform(_, event_id); end
  include Aruba::EventBus::NameResolver::ResolveHelpers
end
class Aruba::EventBus::NameResolver::SymbolResolver
  def self.match?(event_id); end
  def self.supports; end
  def transform(default_namespace, event_id); end
  include Aruba::EventBus::NameResolver::ResolveHelpers
end
class Aruba::EventBus::NameResolver::FailingResolver
  def self.match?(event_id); end
  def self.supports; end
end
class Aruba::Runtime
  def announcer; end
  def announcer=(arg0); end
  def command_monitor; end
  def command_monitor=(arg0); end
  def config; end
  def config=(arg0); end
  def current_directory; end
  def environment; end
  def environment=(arg0); end
  def event_bus; end
  def event_bus=(arg0); end
  def fixtures_directory; end
  def initialize(opts = nil); end
  def logger; end
  def logger=(arg0); end
  def root_directory; end
  def setup_already_done?; end
  def setup_done; end
end
class Aruba::Setup
  def call(clobber = nil); end
  def events; end
  def initialize(runtime); end
  def runtime; end
  def working_directory(clobber = nil); end
end
module Aruba::Api
  include Aruba::Api::Bundler
  include Aruba::Api::Commands
  include Aruba::Api::Core
  include Aruba::Api::Environment
  include Aruba::Api::Filesystem
  include Aruba::Api::Text
end
module Aruba::Api::Core
  def aruba; end
  def cd(dir, &block); end
  def expand_path(file_name, dir_string = nil); end
  def in_current_directory(&block); end
  def setup_aruba(clobber = nil); end
  def with_environment(env = nil, &block); end
  include RSpec::Matchers
end
module Aruba::Processes
end
class Aruba::Processes::BasicProcess
  def after_run; end
  def arguments; end
  def before_run; end
  def close_io(*arg0); end
  def command; end
  def commandline; end
  def content; end
  def environment; end
  def exit_status; end
  def exit_timeout; end
  def filesystem_status; end
  def initialize(cmd, exit_timeout, io_wait_timeout, working_directory, environment = nil, main_class = nil, stop_signal = nil, startup_wait_time = nil); end
  def inspect; end
  def io_wait_timeout; end
  def main_class; end
  def output(opts = nil); end
  def pid; end
  def restart; end
  def send_signal(*arg0); end
  def started?; end
  def startup_wait_time; end
  def stderr(*arg0); end
  def stdin(*arg0); end
  def stdout(*arg0); end
  def stop_signal; end
  def stopped?; end
  def timed_out?; end
  def to_s; end
  def truncate(string, max_length); end
  def wait; end
  def working_directory; end
  def write(*arg0); end
end
class Aruba::Processes::SpawnProcess < Aruba::Processes::BasicProcess
  def close_io(name); end
  def command_path; end
  def command_string; end
  def content; end
  def filesystem_status; end
  def initialize(cmd, exit_timeout, io_wait_timeout, working_directory, environment = nil, main_class = nil, stop_signal = nil, startup_wait_time = nil); end
  def interactive?; end
  def pid; end
  def read_temporary_output_file(file); end
  def self.match?(_mode); end
  def send_signal(signal); end
  def start; end
  def stderr(opts = nil); end
  def stdin; end
  def stdout(opts = nil); end
  def stop(*arg0); end
  def terminate; end
  def wait; end
  def wait_for_io(time_to_wait); end
  def write(input); end
end
class Aruba::Processes::InProcess < Aruba::Processes::BasicProcess
  def close_io(name); end
  def exit_status; end
  def initialize(cmd, exit_timeout, io_wait_timeout, working_directory, environment = nil, main_class = nil, stop_signal = nil, startup_wait_time = nil); end
  def interactive?; end
  def main_class; end
  def pid; end
  def self.match?(mode); end
  def start; end
  def stderr(*arg0); end
  def stdin; end
  def stdout(*arg0); end
  def stop(*arg0); end
  def terminate; end
  def write(input); end
end
class Aruba::Processes::InProcess::FakeKernel
  def exit(exitstatus); end
  def exitstatus; end
  def initialize; end
end
class Aruba::Processes::DebugProcess < Aruba::Processes::BasicProcess
  def close_io(*arg0); end
  def interactive?; end
  def self.match?(mode); end
  def start; end
  def stderr(*arg0); end
  def stdin(*arg0); end
  def stdout(*arg0); end
  def stop(*arg0); end
  def terminate(*arg0); end
  def write(*arg0); end
end
class Aruba::Command < SimpleDelegator
  def event_bus; end
  def initialize(command, opts = nil); end
  def run!; end
  def start; end
  def stop(*arg0); end
  def terminate(*arg0); end
end
module Aruba::Api::Commands
  def all_commands; end
  def all_output; end
  def all_stderr; end
  def all_stdout; end
  def close_input; end
  def find_command(commandline); end
  def last_command_started; end
  def last_command_stopped; end
  def pipe_in_file(file_name); end
  def prepare_command(cmd, opts); end
  def run_command(cmd, opts = nil); end
  def run_command_and_stop(cmd, opts = nil); end
  def start_command(command); end
  def stop_all_commands(&block); end
  def terminate_all_commands(&block); end
  def type(input); end
  def which(program, path = nil); end
end
module Aruba::Api::Environment
  def append_environment_variable(name, value); end
  def delete_environment_variable(name); end
  def prepend_environment_variable(name, value); end
  def set_environment_variable(name, value); end
end
module Aruba::Api::Filesystem
  def absolute?(path); end
  def all_directories; end
  def all_files; end
  def all_paths; end
  def append_to_file(file_name, file_content); end
  def chmod(*args); end
  def copy(*args); end
  def create_directory(directory_name); end
  def directory(path); end
  def directory?(file); end
  def disk_usage(*paths); end
  def executable?(path); end
  def exist?(file_or_directory); end
  def file?(file); end
  def file_size(name); end
  def list(name); end
  def move(*args); end
  def overwrite_file(name, content); end
  def read(name); end
  def relative?(path); end
  def remove(*args); end
  def touch(*args); end
  def with_file_content(file); end
  def write_file(name, content); end
  def write_fixed_size_file(name, size); end
end
module Aruba::Api::Text
  def extract_text(text); end
  def replace_variables(text); end
  def sanitize_text(text); end
  def unescape_text(text); end
end
module Aruba::Api::Bundler
  def unset_bundler_env_vars; end
  include Aruba::Api::Environment
end
module RSpec::Matchers
  def a_command_found_in_path(*args, &block); end
  def a_command_having_output(*args, &block); end
  def a_directory_having_sub_directory(*args, &block); end
  def a_file_having_content(*args, &block); end
  def a_file_name_matching(*args, &block); end
  def a_file_of_size(*args, &block); end
  def a_file_with_same_content_as(*args, &block); end
  def a_path_having_permissions(*args, &block); end
  def a_path_matching_pattern(*args, &block); end
  def an_absolute_path(*args, &block); end
  def an_existing_directory(*args, &block); end
  def an_existing_executable(*args, &block); end
  def an_existing_file(*args, &block); end
  def an_existing_path(*args, &block); end
  def an_output_string_being_eq(*args, &block); end
  def an_output_string_including(*args, &block); end
  def an_output_string_matching(*args, &block); end
  def be_a_command_found_in_path(*expected, &block_arg); end
  def be_an_absolute_path(*expected, &block_arg); end
  def be_an_existing_directory(*expected, &block_arg); end
  def be_an_existing_executable(*expected, &block_arg); end
  def be_an_existing_file(*expected, &block_arg); end
  def be_an_existing_path(*expected, &block_arg); end
  def be_successfully_executed(*expected, &block_arg); end
  def file_content_including(*args, &block); end
  def file_content_matching(*args, &block); end
  def have_exit_status(*expected, &block_arg); end
  def have_failed_running(*args, &block); end
  def have_file_content(*expected, &block_arg); end
  def have_file_size(*expected, &block_arg); end
  def have_finished_in_time(*expected, &block_arg); end
  def have_output(*expected, &block_arg); end
  def have_output_on_stderr(*expected, &block_arg); end
  def have_output_on_stdout(*expected, &block_arg); end
  def have_output_size(*expected, &block_arg); end
  def have_permissions(*expected, &block_arg); end
  def have_same_file_content_as(*expected, &block_arg); end
  def have_sub_directory(*expected, &block_arg); end
  def include_an_object(expected); end
  def include_output_string(*expected, &block_arg); end
  def match_output_string(*expected, &block_arg); end
  def output_string_eq(*expected, &block_arg); end
  def run_too_long(*args, &block); end
end
module Aruba::Matchers
  def all(expected); end
  def self.all(expected); end
  include RSpec::Matchers
end
module Aruba::Matchers::ObjectFormatter
  def self.format(object); end
  def self.format_date_time(date_time); end
  def self.format_time(time); end
  def self.prepare_for_inspection(object); end
  def self.prepare_hash(input); end
end
class Aruba::Matchers::ObjectFormatter::InspectableItem < Struct
  def inspect; end
  def inspection; end
  def inspection=(_); end
  def pretty_print(pp); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Aruba::Matchers::ObjectFormatter::DelegatingInspector < Struct
  def inspect; end
  def object; end
  def object=(_); end
  def pretty_print(pp); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Aruba::Matchers::BaseMatcher
  def actual; end
  def description_of(object); end
  def expected; end
  def initialize(expected = nil); end
  def iterable?; end
  def matches?(actual); end
  def rescued_exception; end
  include Aruba::Matchers::BaseMatcher::DefaultFailureMessages
  include Aruba::Matchers::BaseMatcher::HashFormatting
end
module Aruba::Matchers::BaseMatcher::HashFormatting
  def improve_hash_formatting(inspect_string); end
  def self.improve_hash_formatting(inspect_string); end
end
module Aruba::Matchers::BaseMatcher::DefaultFailureMessages
  def failure_message; end
  def failure_message_when_negated; end
  def self.has_default_failure_messages?(matcher); end
end
module Aruba::Matchers::Base
end
module Aruba::Matchers::Base::MessageIndenter
  def indent_multiline_message(message); end
  def self.indent_multiline_message(message); end
end
class Aruba::Matchers::IncludeAnObject < Aruba::Matchers::BaseMatcher
  def add_new_line_if_needed(message); end
  def any_succeeded_object; end
  def any_succeeded_object=(arg0); end
  def description; end
  def does_not_match?(actual); end
  def failed_objects; end
  def failure_message; end
  def failure_message_for_item(index, failure_message); end
  def index_objects; end
  def initialize(matcher); end
  def match(expected, actual); end
  def matcher; end
  include Aruba::Matchers::Base::MessageIndenter
end
module RSpec
end
